# 一、声明对象类型



```typescript
// 通过类型(type)别名来声明对象类型
// type InfoType = {name: string, age: number}

// 另外一种方式声明对象类型: 接口interface
// 在其中可以定义可选类型
// 也可以定义只读属性
interface IInfoType {
  readonly name: string
  age: number
  friend?: {
    name: string
  }
}

const info: IInfoType = {
  name: "why",
  age: 18,
  friend: {
    name: "kobe"
  }
}

console.log(info.friend?.name)//kobe
console.log(info.name)//why
// info.name = "123"//无法分配到 "name" ，因为它是只读属性
info.age = 20


```







# 二、索引类型



```typescript
// 通过interface来定义索引类型
interface IndexLanguage {
  [index: number]: string
}

const frontLanguage: IndexLanguage = {
  0: "HTML",
  1: "CSS",
  2: "JavaScript",
  3: "Vue"
}

console.log(frontLanguage[1]);//CSS

interface ILanguageYear {
  [name: string]: number
}

const languageYear: ILanguageYear = {
  "C": 1972,
  "Java": 1995,
  "JavaScript": 1996,
  "TypeScript": 2014
}
console.log(languageYear.C);//1972

```







# 三、函数类型

```typescript
// type CalcFn = (n1: number, n2: number) => number
// 可调用的接口
interface CalcFn {
  (n1: number, n2: number): number; //两个参数一个返回值
}

function calc(num1: number, num2: number, calcFn: CalcFn) {
  return calcFn(num1, num2);
}

const add: CalcFn = (num1, num2) => {
  return num1 + num2;
};

calc(20, 30, add);
```



# 四、接口继承

```typescript
interface ISwim {
  swimming: () => void
}

interface IFly {
  flying: () => void
}


interface IAction extends ISwim, IFly {//继承ISwim和IFly接口,并且两个接口的值都需有

}

const action: IAction = {
  swimming() {

  },
  flying() {
    
  }
}
```



# 五、交叉类型

```typescript
// 一种组合类型的方式: 联合类型
type WhyType = number | string
type Direction = "left" | "right" | "center"


// 另一种组件类型的方式: 交叉类型
type WType = number & string

interface ISwim {
  swimming: () => void
}

interface IFly {
  flying: () => void
}

type MyType1 = ISwim | IFly//最少有一个接口的值存在
type MyType2 = ISwim & IFly//两个接口与的值必须同时存在

const obj1: MyType1 = {
  flying() {

  },
  swimming() {

  },
}

const obj2: MyType2 = {
  swimming() {

  },
  flying() {
    
  }
}

export {}
```

