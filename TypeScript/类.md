# 一、类的继承



## 1、需注意

+ 类继承时必须调用被继承人的 **super()** 方法
+ 类继承时也可 **重写** 被继承类的 **值与方法** ，也可 **即调用被继承类值与方法，也调用被继承类的值和方法**

```typescript
class Person {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.age = age;
    this.name = name;
  }
  eating() {
    console.log("eating");
  }
}
class Student extends Person {
  sno: number;
  constructor(name: string, age: number, sno: number) {
    super(name, age);//调用被继承类 super
    this.sno = sno;
  }
    eating(){//重写被继承的方法
      
        super.eating()//调用被继承类的方法
        console.log("studenteating");

    }
  studying() {
    console.log("studying");
  }
}
const stu = new Student("name", 18, 18041322);
console.log(stu.name, stu.age, stu.sno);
console.log(stu.eating());

export {};

```





# 二、设置获取类中的值(get&set)



```typescript
class Person {
  private _name: string;
  constructor(name: string) {
    this._name = name;
  }
  set name(newName) {
    this._name = newName;
  }
  get name() {
    return this._name;
  }
}
let person = new Person("lpz");
person.name = "coder";
console.log(person.name);

```



# 三、类的静态成员

+ 静态成员可无需 new 直接访问其中的值

```typescript
class Student {
  static time: string = "20:00";
  static attendClass(){
      console.log('去学习~');
      
  }
}
console.log(Student.time);
Student.attendClass()


export {};

```



# 四、抽象类abstract

## 1、定义

+ **什么是 抽象方法? 在TypeScript中没有具体实现的方法(没有方法体)，就是抽象方法。**
  + 抽象方法，必须存在于抽象类中；
  + 抽象类是使用abstract声明的类；

## 2、需注意

+ 抽象类是不能被实例的话（也就是不能通过new创建） 
+ 抽象方法必须被子类实现，否则该类必须是一个抽象类



```typescript

function makeArea(shape: Shape) {
    return shape.getArea()
  }
  
  
  abstract class Shape {//抽象类
    abstract getArea(): number//抽象方法
  }
  
  
  class Rectangle extends Shape {
    private width: number
    private height: number
  
    constructor(width: number, height: number) {
      super()//即便是抽象类也要调用父的构造函数
      this.width = width
      this.height = height
    }
  
    getArea() {//抽象方法在子类中使用
      return this.width * this.height
    }
  }
  
  class Circle extends Shape {
    private r: number
  
    constructor(r: number) {
      super()
      this.r = r
    }
  
    getArea() {//抽象方法在子类中使用
      return this.r * this.r * 3.14
    }
  }
  
  const rectangle = new Rectangle(20, 30)
  const circle = new Circle(10)
  
  console.log(makeArea(rectangle))
  console.log(makeArea(circle))
  // makeArea(new Shape())
  
  // makeArea(123)
  // makeArea("123")
  
  
```



# 五、类的类型

+  **类定义类型 ** 

```typescript
class Person {
    name: string = "123"
    eating() {
  
    }
  }
  
  const p = new Person()
  
  const p1: Person = {
    name: "why",
    eating() {
  
    }
  }
  
  function printPerson(p: Person) {
    console.log(p.name)
  }
  
  printPerson(new Person())
  printPerson({name: "kobe", eating: function() {}})
  
  export {}
  
  
```

















